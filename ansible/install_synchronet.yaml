---
# Ansible playbook to install and configure Synchronet BBS
# This playbook will:
# - Create sbbs user and set up dependencies
# - Install Synchronet from source
# - Configure basic runtime environment
# Only rebuilds/reinstalls if sbbs binary is missing or non-functional

- hosts: all
  become: "yes"
  vars:
    ansible_become_method: sudo
    ansible_become_flags: "-H -S -n"
    ansible_python_interpreter: auto_silent
    ansible_become_pass: ""
    ansible_remote_tmp: /tmp/.ansible-${USER}
    sbbs_user: sbbs
    sbbs_home: /home/{{ sbbs_user }}
    sbbs_dir: "{{ sbbs_home }}/sbbs"
    repo_dir: "{{ sbbs_dir }}/repo"
    sbbs_symlink: "{{ sbbs_dir }}/exec/sbbs"
    hostname: c64.pub
    bbs_hostname: "bbs.{{ hostname }}"
    time_zone: America/Chicago

  tasks:
    - name: Create ansible remote temp directory with proper permissions
      file:
        path: /tmp/.ansible-${USER}
        state: directory
        mode: "0700"
      ignore_errors: yes

    - name: Add Group sbbs
      group:
        name: sbbs

    - name: Ensure sbbs user exists
      user:
        name: "{{ sbbs_user }}"
        shell: /bin/bash
        groups: wheel,sbbs,docker
        append: "yes"
        create_home: "yes"

    - name: Configure passwordless sudo for sbbs user
      lineinfile:
        path: /etc/sudoers.d/sbbs
        line: "{{ sbbs_user }} ALL=(ALL) NOPASSWD:ALL"
        create: yes
        mode: "0440"
        validate: "visudo -cf %s"

    - name: Install system dependencies
      dnf:
        name:
          - git
          - "@Development Tools"
          - pkg-config
          - ncurses-devel
          - libarchive-devel
          - openssl-devel
          - libcurl-devel
          - nspr-devel
          - nss-devel
          - libcap-devel
          - zip
          - unzip
          - telnet
          - rsyslog
          - docker
          - python3-pip
          - python3-cryptography
        state: present

    - name: Set timezone to Central US (Chicago)
      timezone:
        name: "{{ time_zone }}"

    - name: Check if SBBS symlink exists
      stat:
        path: "{{ sbbs_symlink }}"
        follow: no
      register: symlink_check

    - name: Get sbbs binary path from symlink
      command: readlink -f {{ sbbs_symlink }}
      register: sbbs_binary_path
      ignore_errors: yes
      when: symlink_check.stat.exists
      changed_when: false

    - name: Set binary path fact
      set_fact:
        sbbs_binary: "{{ sbbs_binary_path.stdout | default(repo_dir + '/src/sbbs3/gcc.linux.x64.exe.release/sbbs') }}"

    - name: Check if sbbs binary exists and works
      become_user: "{{ sbbs_user }}"
      command: "{{ sbbs_binary }} version"
      register: sbbs_check
      ignore_errors: yes
      changed_when: false
      when: symlink_check.stat.exists

    - name: Display SBBS version
      debug:
        msg: "{{ sbbs_check.stdout }}"
      when: sbbs_check is defined and sbbs_check.stdout is defined and sbbs_check.rc == 0

    - name: Configure environment
      lineinfile:
        path: "{{ sbbs_home }}/.bashrc"
        line: export SBBSCTRL={{ sbbs_dir }}/ctrl
        insertafter: EOF
        owner: "{{ sbbs_user }}"
        group: "{{ sbbs_user }}"
        mode: "0644"

    - block:
        - name: Create synchronet directory
          become_user: "{{ sbbs_user }}"
          file:
            path: "{{ sbbs_dir }}"
            state: directory
            owner: "{{ sbbs_user }}"
            group: "{{ sbbs_user }}"

        - name: Clone Synchronet source repo to repo subdirectory
          become_user: "{{ sbbs_user }}"
          git:
            repo: https://gitlab.synchro.net/main/sbbs.git
            dest: "{{ repo_dir }}"
            version: master
            update: "yes"
            force: yes

        - name: Build Synchronet (all components)
          become_user: "{{ sbbs_user }}"
          shell: |
            make -j{{ ansible_processor_cores }} RELEASE=1
          args:
            chdir: "{{ repo_dir }}/src/sbbs3"

        - name: Create runtime directories and install Synchronet
          become_user: "{{ sbbs_user }}"
          shell: |
            make -f install/install-sbbs.mk run
            make -f install/install-sbbs.mk RELEASE=1 SYMLINK=1 NOCAP=1
          args:
            chdir: "{{ repo_dir }}"
          environment:
            SBBSDIR: "{{ sbbs_dir }}"
          notify: restart sbbs

      when: not symlink_check.stat.exists or (sbbs_check is defined and sbbs_check.rc != 0)

    - name: Set TelnetInterface for BBS in sbbs.ini
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^([ \t]*)TelnetInterface[ \t]*=.*$'
        line: '\1TelnetInterface = 0.0.0.0, 0.0.0.0:64, 0.0.0.0:128'
        backrefs: yes
      become_user: "{{ sbbs_user }}"
      ignore_errors: yes
      notify: restart sbbs

    - name: Set capability on actual binary for binding to privileged ports
      command: setcap cap_net_bind_service=+ep "{{ sbbs_binary }}"
      become: yes
      ignore_errors: yes
      changed_when: false

    - name: Create symbolic link to scfg in sbbs home directory
      file:
        src: "{{ sbbs_dir }}/exec/scfg"
        dest: "{{ sbbs_home }}/scfg"
        state: link
        owner: "{{ sbbs_user }}"
        group: "{{ sbbs_user }}"
      become_user: "{{ sbbs_user }}"

    - name: Check if SBBS log file exists
      stat:
        path: /var/log/sbbs.log
      register: sbbs_log_exists

    - name: Create SBBS log file
      file:
        path: /var/log/sbbs.log
        state: touch
        owner: "{{ sbbs_user }}"
        group: "{{ sbbs_user }}"
        mode: "0644"
        modification_time: preserve
        access_time: preserve
      when: not sbbs_log_exists.stat.exists

    - name: Configure rsyslog for SBBS logging
      copy:
        content: |
          # SBBS logging configuration
          local3.*                 /var/log/sbbs.log
          # Exclude local3 from messages log
          *.*;local3.none          /var/log/messages
        dest: /etc/rsyslog.d/50-sbbs.conf
        owner: root
        group: root
        mode: "0644"
      notify: restart rsyslog

    - name: Start and enable rsyslog service
      systemd:
        name: rsyslog
        state: started
        enabled: yes

    - name: Configure SSH session timeout (24 hours)
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "^#?ClientAliveInterval"
        line: "ClientAliveInterval 300"
        backup: yes
      notify: restart sshd

    - name: Configure SSH max alive count for 24h timeout
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "^#?ClientAliveCountMax"
        line: "ClientAliveCountMax 288"
        backup: yes
      notify: restart sshd

    - name: Configure SBBS LogFacility in sbbs.ini
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^(\s*)LogFacility\s*=\s*.*$'
        line: '\1LogFacility = 3'
        backrefs: yes
      become_user: "{{ sbbs_user }}"
      ignore_errors: yes
      notify: restart sbbs

    - name: Configure SBBS LogLevel to Debugging in sbbs.ini
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^(\s*)LogLevel\s*=\s*.*$'
        line: '\1LogLevel = Debugging'
        backrefs: yes
      become_user: "{{ sbbs_user }}"
      ignore_errors: yes
      notify: restart sbbs

    - name: Set Options for [Web] section in sbbs.ini to NO_CGI | NO_HOST_LOOKUP
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^\s*Options\s*=.*$'
        line: "Options = NO_CGI | NO_HOST_LOOKUP"
        backrefs: yes
        insertafter: '^\[Web\]'
      become_user: "{{ sbbs_user }}"
      notify: restart sbbs

    - name: Ensure create_self_signed_cert is set to false in main.ini
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/main.ini"
        regexp: '^\s*create_self_signed_cert\s*=.*$'
        line: "create_self_signed_cert=false"
        backrefs: yes
        create: yes
      become_user: "{{ sbbs_user }}"

    - name: Comment out all non-blank, uncommented lines after [WSS] except Port=11235, stopping at next section header
      shell: |
        awk '
        BEGIN {in_section=0}
        /^\[WSS\]$/ {in_section=1; print; next}
        /^\[/ {if(in_section){in_section=0}; print; next}
        in_section && $0 !~ /^\s*$/ && $0 !~ /^Port=11235$/ && $0 !~ /^;/ {
          print ";" $0
          next
        }
        {print}
        ' {{ sbbs_dir }}/ctrl/services.ini > {{ sbbs_dir }}/ctrl/services.ini.tmp && mv {{ sbbs_dir }}/ctrl/services.ini.tmp {{ sbbs_dir }}/ctrl/services.ini
      become_user: "{{ sbbs_user }}"
      notify: restart sbbs

    - name: Setup logrotate for SBBS logs
      copy:
        content: |
          /var/log/sbbs*.log {
              weekly
              missingok
              rotate 52
              notifempty
              create 640 {{ sbbs_user }} {{ sbbs_user }}
              sharedscripts
              postrotate
                  /bin/systemctl reload rsyslog > /dev/null 2>&1 || true
              endscript
          }
        dest: /etc/logrotate.d/sbbs
        owner: root
        group: root
        mode: "0644"

    - name: Create systemd service file
      template:
        src: sbbs.service.j2
        dest: /etc/systemd/system/sbbs.service
        owner: root
        group: root
        mode: "0644"
      notify: reload systemd

    - name: Configure Synchronet web server to use port 8080
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^(\s*)Port\s*=\s*80\s*$'
        line: '\1Port = 8080'
        backrefs: yes
        create: yes
      become_user: "{{ sbbs_user }}"

    - name: Remove Synchronet HTTPS port configuration (Nginx handles SSL)
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^\s*Port\s*=\s*443\s*$'
        state: absent
      become_user: "{{ sbbs_user }}"

    - name: Ensure Synchronet web server is enabled
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^(\s*)AutoStart\s*=\s*.*$'
        line: '\1AutoStart = true'
        backrefs: yes
        create: yes
      become_user: "{{ sbbs_user }}"

    - name: Ensure SBBS ipfilter_exempt.cfg exists
      file:
        path: "{{ sbbs_dir }}/ctrl/ipfilter_exempt.cfg"
        state: touch
        owner: "{{ sbbs_user }}"
        group: "{{ sbbs_user }}"
        mode: "0644"
      become_user: "{{ sbbs_user }}"

    - name: Get IMDSv2 token from EC2 metadata service (on instance)
      shell: |
        curl -s -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 60"
      register: imds_token
      changed_when: false

    - name: Get EC2 public IP from metadata (IMDSv2, on instance)
      shell: |
        curl -s -H "X-aws-ec2-metadata-token: {{ imds_token.stdout }}" http://169.254.169.254/latest/meta-data/public-ipv4 || true
      register: ec2_public_ip
      changed_when: false

    - name: Get EC2 private IP from metadata (IMDSv2, on instance)
      shell: |
        curl -s -H "X-aws-ec2-metadata-token: {{ imds_token.stdout }}" http://169.254.169.254/latest/meta-data/local-ipv4 || true
      register: ec2_private_ip
      changed_when: false

    - name: Exempt EC2 public and private IPs from SBBS IP filter
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/ipfilter_exempt.cfg"
        line: "{{ item }}"
        create: yes
        state: present
      loop:
        - "{{ ec2_public_ip.stdout }}"
        - "{{ ec2_private_ip.stdout }}"
      become_user: "{{ sbbs_user }}"
      when:
        - ec2_public_ip.stdout | length > 0 or ec2_private_ip.stdout | length > 0

    - name: Enable and start Synchronet SBBS service
      systemd:
        name: sbbs
        enabled: yes
        state: started

    # Install and configure Nginx with SSL/TLS
    - name: Check what is using port 80
      shell: |
        echo "Checking port 80 usage:"
        lsof -i :80 || echo "No processes found on port 80"
        netstat -tlnp | grep :80 || echo "No listeners on port 80"
      register: port_80_check
      ignore_errors: yes

    - name: Display port 80 usage
      debug:
        msg: "{{ port_80_check.stdout }}"

    - name: Install Nginx and related packages
      dnf:
        name:
          - nginx
          - certbot
          - python3-certbot-nginx
        state: present

    - name: Remove default Nginx configuration
      file:
        path: /etc/nginx/conf.d/default.conf
        state: absent

    - name: Disable default Nginx site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      ignore_errors: yes

    - name: Create basic Nginx configuration for initial startup
      copy:
        content: |
          server {
              listen 80;
              server_name _;
              return 200 'Nginx is running';
              add_header Content-Type text/plain;
          }
        dest: /etc/nginx/conf.d/basic.conf
        owner: root
        group: root
        mode: "0644"

    - name: Start and enable Nginx service
      systemd:
        name: nginx
        state: started
        enabled: yes

    - name: Check if SSL certificate already exists
      stat:
        path: /etc/letsencrypt/live/{{ bbs_hostname }}/fullchain.pem
      register: ssl_cert_exists

    - name: Check if current certificate includes all required domains
      shell: |
        openssl x509 -in /etc/letsencrypt/live/{{ bbs_hostname }}/fullchain.pem -text -noout | \
        grep -E "DNS:({{ bbs_hostname }}|{{ hostname }}|www\.{{ hostname }}|xterm\.{{ hostname }})" | \
        wc -l
      register: cert_domain_count
      ignore_errors: yes
      when: ssl_cert_exists.stat.exists
      changed_when: false

    - name: Set fact for certificate renewal needed
      set_fact:
        cert_renewal_needed: "{{ not ssl_cert_exists.stat.exists or (ssl_cert_exists.stat.exists and cert_domain_count.stdout|int < 4) }}"

    - name: Replace basic config with SSL setup config
      copy:
        content: |
          server {
              listen 80 default_server;
              server_name {{ bbs_hostname }};
              
              location /.well-known/acme-challenge/ {
                  root /var/www/html;
              }
              
              location / {
                  return 200 'SSL certificate setup in progress';
                  add_header Content-Type text/plain;
              }
          }
        dest: /etc/nginx/conf.d/basic.conf
        owner: root
        group: root
        mode: "0644"
      when: not ssl_cert_exists.stat.exists
      notify: reload nginx

    - name: Flush handlers to reload Nginx before SSL setup
      meta: flush_handlers

    - name: Create webroot directory for Let's Encrypt
      file:
        path: /var/www/html
        state: directory
        mode: "0755"

    - name: Create xterm webroot directory
      file:
        path: /var/www/xterm
        state: directory
        mode: "0755"

    - name: Create xterm index.html
      tags: ["websocket", "xterm"]
      template:
        src: xterm/index.html
        dest: /var/www/html/xterm/index.html
        owner: root
        group: root
        mode: "0644"

    # WebSocket-to-telnet bridge setup - Using Node.js bridge
    - name: Install Node.js for WebSocket bridge
      dnf:
        name:
          - nodejs
          - npm
        state: present

    - name: Create WebSocket bridge directory
      file:
        path: /opt/websocket-bridge
        state: directory
        owner: ec2-user
        group: ec2-user
        mode: "0755"

    - name: Create package.json for WebSocket bridge
      copy:
        content: |
          {
            "name": "telnet-websocket-bridge",
            "version": "1.0.0",
            "description": "WebSocket to Telnet bridge for BBS",
            "main": "bridge.js",
            "dependencies": {
              "ws": "^8.14.2"
            }
          }
        dest: /opt/websocket-bridge/package.json
        owner: ec2-user
        group: ec2-user
        mode: "0644"

    - name: Create WebSocket to Telnet bridge script
      copy:
        content: |
          const WebSocket = require('ws');
          const net = require('net');

          console.log('Starting WebSocket to Telnet bridge...');

          const wss = new WebSocket.Server({ 
            port: 11236,
            perMessageDeflate: false
          });

          wss.on('connection', function connection(ws, req) {
            console.log('New WebSocket connection from:', req.socket.remoteAddress);
            console.log('Connection headers:', req.headers);
            
            // Create telnet connection
            const telnet = new net.Socket();
            telnet.setKeepAlive(true, 30000); // Keep TCP connection alive
            
            let connected = false;
            
            // Connect to telnet server
            telnet.connect(23, '127.0.0.1', function() {
              console.log('Connected to telnet server');
              connected = true;
            });
            

            
            // Forward data from WebSocket to telnet (only if connected)
            ws.on('message', function incoming(data) {
              console.log('WS->Telnet:', data.length + ' bytes');
              if (connected && telnet.writable) {
                telnet.write(data);
              } else {
                console.log('Telnet not ready, dropping message');
              }
            });
            
            // Forward data from telnet to WebSocket
            telnet.on('data', function(data) {
              console.log('Telnet->WS:', data.length + ' bytes');
              if (ws.readyState === WebSocket.OPEN) {
                ws.send(data);
              }
            });
            
            // Handle disconnections
            ws.on('close', function(code, reason) {
              console.log('WebSocket closed with code:', code, 'reason:', reason);
              connected = false;
              telnet.destroy();
            });
            
            telnet.on('close', function() {
              console.log('Telnet connection closed');
              connected = false;
              if (ws.readyState === WebSocket.OPEN) {
                console.log('Closing WebSocket due to telnet close');
                ws.close();
              }
            });
            
            telnet.on('error', function(err) {
              console.error('Telnet error:', err);
              connected = false;
              if (ws.readyState === WebSocket.OPEN) {
                ws.close();
              }
            });
            
            ws.on('error', function(err) {
              console.error('WebSocket error:', err);
              connected = false;
              telnet.destroy();
            });
          });

          console.log('WebSocket bridge listening on port 11236');
        dest: /opt/websocket-bridge/bridge.js
        owner: ec2-user
        group: ec2-user
        mode: "0644"

    - name: Install npm dependencies for WebSocket bridge
      npm:
        path: /opt/websocket-bridge
        state: present
      become_user: ec2-user

    - name: Create websockify service for BBS telnet bridge
      copy:
        content: |
          [Unit]
          Description=WebSocket to Telnet Bridge for BBS
          After=network.target

          [Service]
          Type=simple
          User=ec2-user
          Group=ec2-user
          WorkingDirectory=/opt/websocket-bridge
          ExecStart=/usr/bin/node bridge.js
          Restart=always
          RestartSec=5
          Environment=NODE_ENV=production

          [Install]
          WantedBy=multi-user.target
        dest: /etc/systemd/system/websockify-bbs.service
        owner: root
        group: root
        mode: "0644"
      notify: reload systemd

    - name: Start and enable websockify service
      systemd:
        name: websockify-bbs
        state: started
        enabled: yes
        daemon_reload: yes

    - name: Obtain SSL certificate from Let's Encrypt
      command: >
        certbot certonly --webroot -w /var/www/html
        -d {{ bbs_hostname }} -d {{ hostname }} -d www.{{ hostname }} -d xterm.{{ hostname }}
        --email admin@{{ bbs_hostname }}
        --agree-tos --non-interactive --expand
      register: certbot_result
      when: cert_renewal_needed
      ignore_errors: yes
      notify: reload nginx

    - name: Display certbot result
      debug:
        msg: "{{ certbot_result.stdout if certbot_result.stdout is defined else certbot_result.stderr }}"
      when: cert_renewal_needed and certbot_result is defined

    - name: Force nginx reload after certificate update
      systemd:
        name: nginx
        state: reloaded
      when: cert_renewal_needed and certbot_result is defined and certbot_result.rc == 0

    - name: Fail if SSL certificate generation failed
      fail:
        msg: "SSL certificate generation failed. Please check DNS configuration for {{ bbs_hostname }}"
      when: cert_renewal_needed and certbot_result is defined and certbot_result.rc != 0

    - name: Remove basic Nginx configuration
      file:
        path: /etc/nginx/conf.d/basic.conf
        state: absent

    - name: Deploy final Nginx configuration with SSL
      template:
        src: nginx-ssl.conf.j2
        dest: /etc/nginx/conf.d/{{ bbs_hostname }}.conf
        owner: root
        group: root
        mode: "0644"
      notify: reload nginx

    - name: Test Nginx configuration
      command: nginx -t
      register: nginx_config_test
      changed_when: false

    - name: Display Nginx config test results
      debug:
        msg: "{{ nginx_config_test.stderr }}"
      when: nginx_config_test.rc != 0

    - name: Fail if Nginx configuration is invalid
      fail:
        msg: "Nginx configuration test failed"
      when: nginx_config_test.rc != 0

    - name: Setup automatic SSL certificate renewal with systemd timer
      copy:
        content: |
          [Unit]
          Description=Renew Let's Encrypt certificates
          After=network-online.target
          Wants=network-online.target

          [Service]
          Type=oneshot
          ExecStart=/usr/bin/certbot renew --quiet
          ExecStartPost=/usr/bin/systemctl reload nginx
        dest: /etc/systemd/system/certbot-renew.service
        owner: root
        group: root
        mode: "0644"

    - name: Create systemd timer for SSL certificate renewal
      copy:
        content: |
          [Unit]
          Description=Run certbot renewal daily
          Requires=certbot-renew.service

          [Timer]
          OnCalendar=daily
          RandomizedDelaySec=3600
          Persistent=true

          [Install]
          WantedBy=timers.target
        dest: /etc/systemd/system/certbot-renew.timer
        owner: root
        group: root
        mode: "0644"

    - name: Reload systemd daemon for timer
      systemd:
        daemon_reload: yes

    - name: Enable and start certbot renewal timer
      systemd:
        name: certbot-renew.timer
        enabled: yes
        state: started

    - name: Start Synchronet SBBS service with new configuration
      systemd:
        name: sbbs
        state: started
        enabled: yes

  handlers:
    - name: reload systemd
      systemd:
        daemon_reload: yes

    - name: restart rsyslog
      systemd:
        name: rsyslog
        state: restarted

    - name: restart sshd
      systemd:
        name: sshd
        state: restarted

    - name: restart sbbs
      systemd:
        name: sbbs
        state: restarted

    - name: reload nginx
      systemd:
        name: nginx
        state: reloaded
