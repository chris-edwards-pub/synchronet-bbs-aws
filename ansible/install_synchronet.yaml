---
# Ansible playbook to install and configure Synchronet BBS
# This playbook will:
# - Create sbbs user and set up dependencies
# - Install Synchronet from source
# - Configure basic runtime environment
# Only rebuilds/reinstalls if sbbs binary is missing or non-functional

- hosts: all
  become: "yes"
  vars:
    ansible_become_method: sudo
    ansible_become_flags: "-H -S -n"
    ansible_python_interpreter: auto_silent
    ansible_become_pass: ""
    ansible_remote_tmp: /tmp/.ansible-${USER}
    sbbs_user: sbbs
    sbbs_home: /home/{{ sbbs_user }}
    sbbs_dir: "{{ sbbs_home }}/sbbs"
    repo_dir: "{{ sbbs_dir }}/repo"
    sbbs_symlink: "{{ sbbs_dir }}/exec/sbbs"
    bbs_hostname: bbs.c64.pub
    time_zone: America/Chicago

  tasks:
    - name: Create ansible remote temp directory with proper permissions
      file:
        path: /tmp/.ansible-${USER}
        state: directory
        mode: '0700'
      ignore_errors: yes

    - name: Add Group sbbs
      group:
        name: sbbs

    - name: Ensure sbbs user exists
      user:
        name: "{{ sbbs_user }}"
        shell: /bin/bash
        groups: wheel,sbbs,docker
        append: "yes"
        create_home: "yes"

    - name: Configure passwordless sudo for sbbs user
      lineinfile:
        path: /etc/sudoers.d/sbbs
        line: "{{ sbbs_user }} ALL=(ALL) NOPASSWD:ALL"
        create: yes
        mode: "0440"
        validate: "visudo -cf %s"

    - name: Install system dependencies
      dnf:
        name:
          - git
          - "@Development Tools"
          - pkg-config
          - ncurses-devel
          - libarchive-devel
          - openssl-devel
          - libcurl-devel
          - nspr-devel
          - nss-devel
          - libcap-devel
          - zip
          - unzip
          - telnet
          - rsyslog
          - docker
          - python3-pip
          - python3-cryptography
        state: present

    - name: Set timezone to Central US (Chicago)
      timezone:
        name: "{{ time_zone }}"

    - name: Check if SBBS symlink exists
      stat:
        path: "{{ sbbs_symlink }}"
        follow: no
      register: symlink_check

    - name: Get sbbs binary path from symlink
      command: readlink -f {{ sbbs_symlink }}
      register: sbbs_binary_path
      ignore_errors: yes
      when: symlink_check.stat.exists
      changed_when: false

    - name: Set binary path fact
      set_fact:
        sbbs_binary: "{{ sbbs_binary_path.stdout | default(repo_dir + '/src/sbbs3/gcc.linux.x64.exe.release/sbbs') }}"

    - name: Check if sbbs binary exists and works
      become_user: "{{ sbbs_user }}"
      command: "{{ sbbs_binary }} version"
      register: sbbs_check
      ignore_errors: yes
      changed_when: false
      when: symlink_check.stat.exists

    - name: Display SBBS version
      debug:
        msg: "{{ sbbs_check.stdout }}"
      when: sbbs_check is defined and sbbs_check.stdout is defined and sbbs_check.rc == 0

    - name: Configure environment
      lineinfile:
        path: "{{ sbbs_home }}/.bashrc"
        line: export SBBSCTRL={{ sbbs_dir }}/ctrl
        insertafter: EOF
        owner: "{{ sbbs_user }}"
        group: "{{ sbbs_user }}"
        mode: "0644"

    - block:
        - name: Create synchronet directory
          become_user: "{{ sbbs_user }}"
          file:
            path: "{{ sbbs_dir }}"
            state: directory
            owner: "{{ sbbs_user }}"
            group: "{{ sbbs_user }}"

        - name: Clean up previous installation
          become_user: "{{ sbbs_user }}"
          shell: |
            rm -rf ctrl docs exec node? text web webv4 xtrn mods repo
          args:
            chdir: "{{ sbbs_dir }}"
          ignore_errors: yes

        - name: Clone Synchronet source repo to repo subdirectory
          become_user: "{{ sbbs_user }}"
          git:
            repo: https://gitlab.synchro.net/main/sbbs.git
            dest: "{{ repo_dir }}"
            version: master
            update: "yes"
            force: yes

        - name: Build Synchronet (all components)
          become_user: "{{ sbbs_user }}"
          shell: |
            make -j{{ ansible_processor_cores }} RELEASE=1
          args:
            chdir: "{{ repo_dir }}/src/sbbs3"

        - name: Create runtime directories and install Synchronet
          become_user: "{{ sbbs_user }}"
          shell: |
            make -f install/install-sbbs.mk run
            make -f install/install-sbbs.mk RELEASE=1 SYMLINK=1 NOCAP=1
          args:
            chdir: "{{ repo_dir }}"
          environment:
            SBBSDIR: "{{ sbbs_dir }}"
          notify: restart sbbs

      when: not symlink_check.stat.exists or (sbbs_check is defined and sbbs_check.rc != 0)

    - name: Set capability on actual binary for binding to privileged ports
      command: setcap cap_net_bind_service=+ep "{{ sbbs_binary }}"
      become: yes
      ignore_errors: yes
      changed_when: false

    - name: Create symbolic link to scfg in sbbs home directory
      file:
        src: "{{ sbbs_dir }}/exec/scfg"
        dest: "{{ sbbs_home }}/scfg"
        state: link
        owner: "{{ sbbs_user }}"
        group: "{{ sbbs_user }}"
      become_user: "{{ sbbs_user }}"

    - name: Check if SBBS log file exists
      stat:
        path: /var/log/sbbs.log
      register: sbbs_log_exists

    - name: Create SBBS log file
      file:
        path: /var/log/sbbs.log
        state: touch
        owner: "{{ sbbs_user }}"
        group: "{{ sbbs_user }}"
        mode: "0644"
        modification_time: preserve
        access_time: preserve
      when: not sbbs_log_exists.stat.exists

    - name: Configure rsyslog for SBBS logging
      copy:
        content: |
          # SBBS logging configuration
          local3.*                 /var/log/sbbs.log
          # Exclude local3 from messages log
          *.*;local3.none          /var/log/messages
        dest: /etc/rsyslog.d/50-sbbs.conf
        owner: root
        group: root
        mode: "0644"
      notify: restart rsyslog

    - name: Start and enable rsyslog service
      systemd:
        name: rsyslog
        state: started
        enabled: yes

    - name: Configure SSH session timeout (24 hours)
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "^#?ClientAliveInterval"
        line: "ClientAliveInterval 300"
        backup: yes
      notify: restart sshd

    - name: Configure SSH max alive count for 24h timeout
      lineinfile:
        path: /etc/ssh/sshd_config
        regexp: "^#?ClientAliveCountMax"
        line: "ClientAliveCountMax 288"
        backup: yes
      notify: restart sshd

    - name: Configure SBBS LogFacility in sbbs.ini
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^(\s*)LogFacility\s*=\s*.*$'
        line: '\1LogFacility = 3'
        backrefs: yes
      become_user: "{{ sbbs_user }}"
      ignore_errors: yes
      notify: restart sbbs

    - name: Configure SBBS LogLevel to Debugging in sbbs.ini
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^(\s*)LogLevel\s*=\s*.*$'
        line: '\1LogLevel = Debugging'
        backrefs: yes
      become_user: "{{ sbbs_user }}"
      ignore_errors: yes
      notify: restart sbbs


    - name: Comment out all non-blank lines after [WSS] except Port=11235, stopping at next section header
      block:
        - name: Get lines after [WSS] in services.ini
          shell: |
            awk '/^\[WSS\]$/ {p=1; next} /^\[/ {p=0} p {print NR}' {{ sbbs_dir }}/ctrl/services.ini
          register: wss_lines
          changed_when: false
          become_user: "{{ sbbs_user }}"
        - name: Comment out lines after [WSS] except Port=11235
          lineinfile:
            path: "{{ sbbs_dir }}/ctrl/services.ini"
            regexp: '^(?!Port=11235)([^\[]\S.*)'
            line: ';\1'
          loop: "{{ wss_lines.stdout_lines }}"
          when: wss_lines.stdout_lines is defined
          become_user: "{{ sbbs_user }}"
          ignore_errors: yes
          notify: restart sbbs

    - name: Setup logrotate for SBBS logs
      copy:
        content: |
          /var/log/sbbs*.log {
              weekly
              missingok
              rotate 52
              notifempty
              create 640 {{ sbbs_user }} {{ sbbs_user }}
              sharedscripts
              postrotate
                  /bin/systemctl reload rsyslog > /dev/null 2>&1 || true
              endscript
          }
        dest: /etc/logrotate.d/sbbs
        owner: root
        group: root
        mode: "0644"

    - name: Create systemd service file
      template:
        src: sbbs.service.j2
        dest: /etc/systemd/system/sbbs.service
        owner: root
        group: root
        mode: "0644"
      notify: reload systemd

    - name: Configure Synchronet web server to use port 8080
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^(\s*)Port\s*=\s*80\s*$'
        line: '\1Port = 8080'
        backrefs: yes
        create: yes
      become_user: "{{ sbbs_user }}"

    - name: Remove Synchronet HTTPS port configuration (Nginx handles SSL)
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^\s*Port\s*=\s*443\s*$'
        state: absent
      become_user: "{{ sbbs_user }}"

    - name: Ensure Synchronet web server is enabled
      lineinfile:
        path: "{{ sbbs_dir }}/ctrl/sbbs.ini"
        regexp: '^(\s*)AutoStart\s*=\s*.*$'
        line: '\1AutoStart = true'
        backrefs: yes
        create: yes
      become_user: "{{ sbbs_user }}"

    - name: Enable and start Synchronet SBBS service
      systemd:
        name: sbbs
        enabled: yes
        state: started

    - name: Flush handlers to restart SBBS with new port configuration
      meta: flush_handlers

    # Install and configure Nginx with SSL/TLS
    - name: Check what is using port 80
      shell: |
        echo "Checking port 80 usage:"
        lsof -i :80 || echo "No processes found on port 80"
        netstat -tlnp | grep :80 || echo "No listeners on port 80"
      register: port_80_check
      ignore_errors: yes

    - name: Display port 80 usage
      debug:
        msg: "{{ port_80_check.stdout }}"

    - name: Install Nginx and related packages
      dnf:
        name:
          - nginx
          - certbot
          - python3-certbot-nginx
        state: present

    - name: Remove default Nginx configuration
      file:
        path: /etc/nginx/conf.d/default.conf
        state: absent

    - name: Disable default Nginx site
      file:
        path: /etc/nginx/sites-enabled/default
        state: absent
      ignore_errors: yes

    - name: Create basic Nginx configuration for initial startup
      copy:
        content: |
          server {
              listen 80;
              server_name _;
              return 200 'Nginx is running';
              add_header Content-Type text/plain;
          }
        dest: /etc/nginx/conf.d/basic.conf
        owner: root
        group: root
        mode: "0644"

    - name: Start and enable Nginx service
      systemd:
        name: nginx
        state: started
        enabled: yes

    - name: Check if SSL certificate already exists
      stat:
        path: /etc/letsencrypt/live/{{ bbs_hostname }}/fullchain.pem
      register: ssl_cert_exists

    - name: Replace basic config with SSL setup config
      copy:
        content: |
          server {
              listen 80 default_server;
              server_name {{ bbs_hostname }};
              
              location /.well-known/acme-challenge/ {
                  root /var/www/html;
              }
              
              location / {
                  return 200 'SSL certificate setup in progress';
                  add_header Content-Type text/plain;
              }
          }
        dest: /etc/nginx/conf.d/basic.conf
        owner: root
        group: root
        mode: "0644"
      when: not ssl_cert_exists.stat.exists
      notify: reload nginx

    - name: Flush handlers to reload Nginx before SSL setup
      meta: flush_handlers

    - name: Create webroot directory for Let's Encrypt
      file:
        path: /var/www/html
        state: directory
        mode: "0755"

    - name: Obtain SSL certificate from Let's Encrypt
      command: >
        certbot certonly --webroot -w /var/www/html
        -d {{ bbs_hostname }}
        --email admin@{{ bbs_hostname }}
        --agree-tos --non-interactive
      register: certbot_result
      when: not ssl_cert_exists.stat.exists
      ignore_errors: yes

    - name: Display certbot result
      debug:
        msg: "{{ certbot_result.stdout if certbot_result.stdout is defined else certbot_result.stderr }}"
      when: not ssl_cert_exists.stat.exists and certbot_result is defined

    - name: Fail if SSL certificate generation failed
      fail:
        msg: "SSL certificate generation failed. Please check DNS configuration for {{ bbs_hostname }}"
      when: not ssl_cert_exists.stat.exists and certbot_result is defined and certbot_result.rc != 0

    - name: Remove basic Nginx configuration
      file:
        path: /etc/nginx/conf.d/basic.conf
        state: absent

    - name: Deploy final Nginx configuration with SSL
      template:
        src: nginx-ssl.conf.j2
        dest: /etc/nginx/conf.d/{{ bbs_hostname }}.conf
        owner: root
        group: root
        mode: "0644"
      notify: reload nginx

    - name: Test Nginx configuration
      command: nginx -t
      register: nginx_config_test
      changed_when: false

    - name: Display Nginx config test results
      debug:
        msg: "{{ nginx_config_test.stderr }}"
      when: nginx_config_test.rc != 0

    - name: Fail if Nginx configuration is invalid
      fail:
        msg: "Nginx configuration test failed"
      when: nginx_config_test.rc != 0

    - name: Setup automatic SSL certificate renewal with systemd timer
      copy:
        content: |
          [Unit]
          Description=Renew Let's Encrypt certificates
          After=network-online.target
          Wants=network-online.target

          [Service]
          Type=oneshot
          ExecStart=/usr/bin/certbot renew --quiet
          ExecStartPost=/usr/bin/systemctl reload nginx
        dest: /etc/systemd/system/certbot-renew.service
        owner: root
        group: root
        mode: "0644"

    - name: Create systemd timer for SSL certificate renewal
      copy:
        content: |
          [Unit]
          Description=Run certbot renewal daily
          Requires=certbot-renew.service

          [Timer]
          OnCalendar=daily
          RandomizedDelaySec=3600
          Persistent=true

          [Install]
          WantedBy=timers.target
        dest: /etc/systemd/system/certbot-renew.timer
        owner: root
        group: root
        mode: "0644"

    - name: Reload systemd daemon for timer
      systemd:
        daemon_reload: yes

    - name: Enable and start certbot renewal timer
      systemd:
        name: certbot-renew.timer
        enabled: yes
        state: started

    - name: Start Synchronet SBBS service with new configuration
      systemd:
        name: sbbs
        state: started
        enabled: yes

  handlers:
    - name: reload systemd
      systemd:
        daemon_reload: yes

    - name: restart rsyslog
      systemd:
        name: rsyslog
        state: restarted

    - name: restart sshd
      systemd:
        name: sshd
        state: restarted

    - name: restart sbbs
      systemd:
        name: sbbs
        state: restarted

    - name: reload nginx
      systemd:
        name: nginx
        state: reloaded
